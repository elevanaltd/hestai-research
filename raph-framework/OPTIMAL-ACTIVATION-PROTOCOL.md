# Optimal Role Activation Protocol for Claude Code

**Version:** 1.0  
**Based on:** Technical analysis of RAPH benchmarking and LLM behavioral mechanics  
**Purpose:** Streamlined, effective role loading without ceremonial overhead

---

## Core Principles

1. **Sequential instruction layering** produces better outputs than monolithic loading
2. **Specific verb choices** create semantic priming effects that influence response quality
3. **TODO-based state tracking** provides external memory without cognitive overhead
4. **Context before complexity** - Ground understanding before loading capabilities

---

## Optimal Activation Sequence

### Phase 1: ESTABLISH Context
```markdown
- [ ] READ system overview and role definition
- [ ] ACKNOWLEDGE base model identity with role overlay
- [ ] VERIFY understanding of working directory and available tools
```
**Purpose:** Ground the session with system awareness and tool availability

### Phase 2: ABSORB Identity  
```markdown
- [ ] INTERNALIZE role prime directive and core tensions
- [ ] RECOGNIZE operational boundaries (MUST_NEVER / ALWAYS_REQUIRES)
- [ ] INTEGRATE identity with base model capabilities
```
**Purpose:** Establish behavioral biases and operational constraints

### Phase 3: PROCESS Capabilities
```markdown
- [ ] MAP available skills to role functions
- [ ] CONNECT patterns to operational needs  
- [ ] ESTABLISH skill activation protocols
```
**Purpose:** Load domain knowledge and specialized capabilities

### Phase 4: SYNTHESIZE Readiness
```markdown
- [ ] HARMONIZE all loaded components into operational framework
- [ ] CONFIRM role activation complete
- [ ] DECLARE readiness with capability summary
```
**Purpose:** Integrate all components and verify activation

---

## Simplified Loading Instructions

```markdown
## Activate HERMES Role

Please activate the HERMES role by sequentially processing these components:

1. **ESTABLISH** - READ the role definition and system context
2. **ABSORB** - INTERNALIZE the identity and operational boundaries  
3. **PROCESS** - MAP skills and capabilities to role functions
4. **SYNTHESIZE** - HARMONIZE all components into readiness

Use this TODO list to track progress:
- [ ] ESTABLISH: Load HERMES_SHAFT.octave META_CONTEXT and guidelines
- [ ] ABSORB: Internalize OPERATIONAL_IDENTITY and boundaries
- [ ] PROCESS: Map POTENTIAL_AND_GOVERNANCE with loaded skills
- [ ] SYNTHESIZE: Integrate SESSION_CONTRACTS and confirm readiness

Required files:
- /config/role-anchors/HERMES_SHAFT.octave
- /config/skills/[RELEVANT_SKILLS].octave
- /config/foundation/hestai-guidelines.octave
- /config/patterns/foundation-patterns.octave
```

---

## Why This Works

### Verb Selection Rationale

**Primary verbs chosen for semantic priming:**
- **ESTABLISH** - Primes for grounding and foundation-setting
- **ABSORB** - Primes for internalization without interpretation
- **PROCESS** - Primes for systematic capability mapping
- **SYNTHESIZE** - Primes for integration and harmonization

**Supporting verbs for clarity:**
- READ, INTERNALIZE, MAP, HARMONIZE - Provide specific action guidance

### Sequential Benefits

1. **Context accumulation** - Each phase adds to available context
2. **Progressive complexity** - Simple grounding → complex integration
3. **Error prevention** - Can't process capabilities without identity
4. **Clear checkpoints** - TODO items provide verification

---

## What We Dropped

### ❌ Removed Ceremony
- No "cognitive stage" claims
- No "boundary enforcement" theater
- No "progressive understanding" language
- No mystical "transcendence" framing
- No lengthy self-summaries

### ✅ Kept Functionality  
- Sequential instruction layering
- Semantic priming through verb choice
- External state tracking
- Clear capability boundaries
- Verification checkpoints

---

## Usage Examples

### Quick Activation (2-3 minutes)
```bash
# For routine tasks with familiar role
- [ ] Load role file and confirm identity
- [ ] Load required skills
- [ ] Begin work
```

### Full Activation (5-7 minutes)
```bash
# For complex tasks or first use in session
- [ ] Complete all four phases
- [ ] Verify each checkpoint
- [ ] Confirm readiness before proceeding
```

### Multi-Role Workflow
```bash
# For tasks requiring role switching
- [ ] Activate PATHOS for exploration
- [ ] Document findings
- [ ] Activate ETHOS for validation  
- [ ] Document constraints
- [ ] Activate LOGOS for synthesis
```

---

## Measurement of Success

### Objective Indicators
- TODO items checked systematically
- Role boundaries respected in outputs
- Appropriate vocabulary for role domain
- Task completion aligns with role strengths

### Quality Markers
- Responses show role-appropriate priorities
- Technical depth matches loaded skills
- No hallucination of capabilities
- Clear operational focus

---

## Anti-Patterns to Avoid

1. **Loading everything at once** - Loses sequential benefits
2. **Skipping identity phase** - Leads to inconsistent behavior
3. **Ignoring TODO tracking** - Loses state management benefits
4. **Over-ceremonializing** - Adds friction without value
5. **Rushing synthesis** - Produces incomplete activation

---

## Technical Notes

- **Token efficiency:** ~500-1000 tokens for full activation
- **Time requirement:** 2-7 minutes depending on depth
- **Persistence:** Role activation persists for conversation duration
- **Switching cost:** ~2-3 minutes to switch roles effectively

---

## Summary

This protocol provides the functional benefits of RAPH (structured loading, semantic priming, state tracking) without the mystical overhead. It's prompt engineering that works, explained honestly.

The 30%+ quality improvements come from:
- Better output organization (sequential structure)
- Semantic activation (verb priming)  
- Context management (TODO tracking)
- Progressive complexity (simple → complex)

Not from cognitive staging or mystical boundaries. Just good prompt engineering.